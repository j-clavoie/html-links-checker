const vscode = require('vscode');
const genFunc = require('../lib/genericFunctions');
const needle = require('needle');
const JSDOM = require('jsdom').JSDOM



// Array of Diagnostics, used to add new link with error
let myDiagnostics = [];
// Read Extension's properties(Configuration)
const defaultDomain = vscode.workspace.getConfiguration("html-links-checker");


// Create a new Collection for Diagnostics
// A Diagnostics Collection must be outsides of an function.
const links_checker_diagColl = vscode.languages.createDiagnosticCollection("html-links-checker");


// Use to clear the "Problems" Tab when we close the file
// TODO: Not working properly - Will clear all error when we close one file...
/* vscode.workspace.onDidCloseTextDocument(function () {
	// clear all previous diagnostics
	links_checker_diagColl.clear();
	links_checker_diagColl.set(vscode.window.activeTextEditor.document.uri, []);
}); */

// This version clear diagnostic when we switch from one to another file but not closing it.
/* vscode.window.onDidChangeVisibleTextEditors(function () {
	// clear all previous diagnostics
	links_checker_diagColl.clear();
	links_checker_diagColl.set(vscode.window.activeTextEditor.document.uri, []);
});
 */
/**
 * @param {vscode.ExtensionContext} context
 */
function activate(context) {

	let disposable = vscode.commands.registerCommand('html-links-checker.a_tag', function () {

		// Check all A tags
		checkAlltag_A();

	});


	// add main function to context array
	context.subscriptions.push(disposable);
}
exports.activate = activate;

function deactivate() {}

module.exports = {
	activate,
	deactivate
}

/* ############################################################################ */
/* ############################################################################ */
/* ############################################################################ */
/* ############################################################################ */

/**
 * Object to put Links report informations for analyze
 */
class LinkResult {
	constructor(link, statusCode, redirected, redirectionLink, error, errorMsg) {
		this.link = link;
		this.statusCode = statusCode || 0;
		this.redirected = redirected || false;
		this.redirectionLink = redirectionLink || undefined;
		this.hasError = error || false;
		this.errorMsg = errorMsg || undefined;
	}
}
/**
 * Object Diagnostic.
 */
class linkDiagnostic {
	constructor(code, message, range, severity) {
		this.code = code || '',
			this.message = message || '',
			this.range = range || undefined,
			this.severity = severity || vscode.DiagnosticSeverity.Warning,
			this.source = "HTML Links Checker"
	}
}



/**
 * Method used to validate a link and and it to the "Problems" tab if response is no 200
 * @param {string} link The URL to analyze
 * @param {Editor Range} linkRange Range of the A tag in the editor
 * @param {string} method The method to use to analyze the URL, by default it's only "head" to get the process faster
 */
function checkLink(link, linkRange, method = 'head') {
	const options = {
		follow_max: 0		// Number of redirections allowed to get a response 200. Set to 0 to get all redirection
	};
	const Result = new LinkResult();
	let addDiagnostic = false;
	switch (String(method)) {
		case 'head':
			needle.head(link, options, function (err, resp) {
				if (err) {
					Result.hasError = true;
					Result.errorMsg = err.message;
					addDiagnostic = true;
				} else if (resp.statusCode == 301 ||
					resp.statusCode == 302 ||
					resp.statusCode == 303 ||
					resp.statusCode == 304) {
					Result.redirected = true;
					Result.redirectionLink = resp.headers.location;
					Result.statusCode = resp.statusCode;
					Result.link = link;
					addDiagnostic = true;
				} else if (resp.statusCode == 200) {
					Result.statusCode = resp.statusCode;
					Result.link = link;
				} else if (resp.statusCode != 200) {
					checkLink(link, linkRange, "get");
				}
				if (addDiagnostic) {
					setDiagnostic(Result, linkRange);
				}
			});
			break;
		case 'get':
			needle.get(link, options, function (err, resp) {
				if (err) {
					Result.hasError = true;
					Result.errorMsg = err.message;
					addDiagnostic = true;
				} else if (resp.statusCode == 301 ||
					resp.statusCode == 302 ||
					resp.statusCode == 303 ||
					resp.statusCode == 304) {
					Result.redirected = true;
					Result.redirectionLink = resp.headers.location;
					addDiagnostic = true;
				} else if (resp.statusCode != 200) {
					Result.statusCode = resp.statusCode;
					Result.link = link;
					addDiagnostic = true;
				}

				if (addDiagnostic) {
					setDiagnostic(Result, linkRange);
				}
			});
			break;
		default:
			break;
	}
}

/**
 * 
 * @param {*} DOMelem Element of DOM to get the range position in Editor
 */
function getDOMelementPosition(DOM, DOMelem) {
	// Get the node location

	const nodeElem = DOM.nodeLocation(DOMelem);

	// Set the range of text the header in error
	const elemRange = new vscode.Range(
		nodeElem.startTag.startLine - 1,
		nodeElem.startTag.startCol - 1,
		nodeElem.startTag.endLine - 1,
		nodeElem.startTag.endCol - 1);

	return elemRange;
}

/**
 * 
 * @param {LinkResult} linkResult Contains the result of link analysis
 * @param {vscode.Range} linkRange Contains the range of the Tag in editor
 */
function setDiagnostic(linkResult, linkRange) {
	const myDiagnostic = new linkDiagnostic();
	myDiagnostic.code = linkResult.statusCode;
	myDiagnostic.range = linkRange;
	if (linkResult.redirected) {
		myDiagnostic.message = "LINK REDIRECTED to " + linkResult.redirectionLink;
		myDiagnostic.severity = vscode.DiagnosticSeverity.Warning;
	} else if (linkResult != 200) {
		myDiagnostic.message = "LINK ERROR - This URL is not working.";
		myDiagnostic.severity = vscode.DiagnosticSeverity.Error;
	}

	myDiagnostics.push(myDiagnostic);
	links_checker_diagColl.set(vscode.window.activeTextEditor.document.uri, myDiagnostics);
}


/**
 * 
 * @param {string} path 
 * Return TRUE is the link is relative, FALSE if not.
 */
function isRelative(thePath) {
	let pathIsRelative = false;

	// Check if the 1st character is a /
	if (thePath.match(/^(\/{1})/g) != null) {
		pathIsRelative = true;
	}
	return pathIsRelative;
}

/**
 * 
 * @param {string} path 
 * Return TRUE is the link is relative, FALSE if not.
 */
function isAnchor(thePath) {
	let pathIsAnchor = false;

	// Check if the 1st character is a /
	if (thePath.match(/^#/g) != null) {
		pathIsAnchor = true;
	}
	return pathIsAnchor;
}


/**
 * 
 * @param {String} anchorLink 
 * @param {*} linkRange 
 * @param {*} DOM 
 */
function checkAnchor(anchorLink, linkRange, DOM) {
	let toReturn;
	anchorLink = anchorLink.replace(/^#/g, '');
	const myDiagnostic = new linkDiagnostic();

	const anchor = DOM.window.document.querySelectorAll("[id='" + anchorLink + "']");
	if (anchor.length !== 1) {
		myDiagnostic.range = linkRange;
		myDiagnostic.severity = vscode.DiagnosticSeverity.Error;
		if (anchor.length == 0) {
			myDiagnostic.message = "LINK ANCHOR - No ID exists with value: '" + anchorLink + "'";
		} else if (anchor.length > 1) {
			myDiagnostic.message = "LINK ANCHOR - More than one ID has the value: '" + anchorLink + "'";
		}

		// Add the diagnostic 
		myDiagnostics.push(myDiagnostic);
		links_checker_diagColl.set(vscode.window.activeTextEditor.document.uri, myDiagnostics);
		// Return false = the anchor is not present in the page or is present more than once.
		toReturn = false;
	} else {
		// Return true, the anchor has been found only once in the page.
		toReturn = true;
	}

	return toReturn;
}


/**
 * Main Method that retrieve all A tag and check if the URL is alive, redirected or not alive
 * If adresse is an email (mailto:), it's not validate with this method.
 * If the domain of the URl is in the ban list, it's not check too
 */
function checkAlltag_A() {
	// clear all previous diagnostics
	links_checker_diagColl.clear();
	myDiagnostics = [];

	// Get the selected text/All text in the active Editor
	const curContent = genFunc.getTextSelected(true);

	// Create a DOM from the selected text
	let myDOM = new JSDOM(curContent, { includeNodeLocations: true, contentType: "text/html" });

	// Retrieve all A tag in the DOM
	const ATags = myDOM.window.document.querySelectorAll('a');

	// For each A tags
	ATags.forEach(function (elem) {
		let continueProcess = true;		// manage the process and exit if required

		// Get the range of the TAG in the Editor
		const elemRange = getDOMelementPosition(myDOM, elem);
		// Check if the link is OK (status 200), else add diagnostics in the "Problems" tab
		let elemURL = elem.getAttribute('href');

		// Check if the URL is an email
		if (elemURL.match(/^\s*mailto:/gmi) != null) {
			continueProcess = false;
		}

		// TODO: Check if domain is in the banned Excluded list in parameters.
		// 			 If yes, pass over this link
		if (false) {
			continueProcess = false;
		}

		// Check if the link is an anchor in the same content (start with #)
		if (continueProcess && isAnchor(elemURL)) {
			checkAnchor(elemURL, elemRange, myDOM);
		} else {
			// Check if the link is relative (start with /)
			if (continueProcess && isRelative(elemURL)) {
				elemURL = defaultDomain.domain + elemURL;
			}

			if (continueProcess) {
				checkLink(elemURL, elemRange);
			}
		}
	});
}